// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pipe.proto

#ifndef PROTOBUF_pipe_2eproto__INCLUDED
#define PROTOBUF_pipe_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace turi {
namespace visualization {
namespace pipe {
class Column;
class ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class FlexDatetime;
class FlexDatetimeDefaultTypeInternal;
extern FlexDatetimeDefaultTypeInternal _FlexDatetime_default_instance_;
class FlexDict;
class FlexDictDefaultTypeInternal;
extern FlexDictDefaultTypeInternal _FlexDict_default_instance_;
class FlexDict_DictEntry;
class FlexDict_DictEntryDefaultTypeInternal;
extern FlexDict_DictEntryDefaultTypeInternal _FlexDict_DictEntry_default_instance_;
class FlexImage;
class FlexImageDefaultTypeInternal;
extern FlexImageDefaultTypeInternal _FlexImage_default_instance_;
class FlexList;
class FlexListDefaultTypeInternal;
extern FlexListDefaultTypeInternal _FlexList_default_instance_;
class FlexNDVector;
class FlexNDVectorDefaultTypeInternal;
extern FlexNDVectorDefaultTypeInternal _FlexNDVector_default_instance_;
class FlexNDVectorDimension;
class FlexNDVectorDimensionDefaultTypeInternal;
extern FlexNDVectorDimensionDefaultTypeInternal _FlexNDVectorDimension_default_instance_;
class FlexUndefined;
class FlexUndefinedDefaultTypeInternal;
extern FlexUndefinedDefaultTypeInternal _FlexUndefined_default_instance_;
class FlexVec;
class FlexVecDefaultTypeInternal;
extern FlexVecDefaultTypeInternal _FlexVec_default_instance_;
class FlexibleType;
class FlexibleTypeDefaultTypeInternal;
extern FlexibleTypeDefaultTypeInternal _FlexibleType_default_instance_;
class TableData;
class TableDataDefaultTypeInternal;
extern TableDataDefaultTypeInternal _TableData_default_instance_;
class TableRow;
class TableRowDefaultTypeInternal;
extern TableRowDefaultTypeInternal _TableRow_default_instance_;
class TableSpec;
class TableSpecDefaultTypeInternal;
extern TableSpecDefaultTypeInternal _TableSpec_default_instance_;
class VegaData;
class VegaDataDefaultTypeInternal;
extern VegaDataDefaultTypeInternal _VegaData_default_instance_;
class VegaSpec;
class VegaSpecDefaultTypeInternal;
extern VegaSpecDefaultTypeInternal _VegaSpec_default_instance_;
}  // namespace pipe
}  // namespace visualization
}  // namespace turi

namespace turi {
namespace visualization {
namespace pipe {

namespace protobuf_pipe_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_pipe_2eproto

enum Column_ColumnType {
  Column_ColumnType_INTEGER = 0,
  Column_ColumnType_FLOAT = 1,
  Column_ColumnType_STRING = 2,
  Column_ColumnType_VECTOR = 3,
  Column_ColumnType_LIST = 4,
  Column_ColumnType_DICT = 5,
  Column_ColumnType_DATETIME = 6,
  Column_ColumnType_UNDEFINED = 7,
  Column_ColumnType_IMAGE = 8,
  Column_ColumnType_ND_VECTOR = 9,
  Column_ColumnType_Column_ColumnType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Column_ColumnType_Column_ColumnType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Column_ColumnType_IsValid(int value);
const Column_ColumnType Column_ColumnType_ColumnType_MIN = Column_ColumnType_INTEGER;
const Column_ColumnType Column_ColumnType_ColumnType_MAX = Column_ColumnType_ND_VECTOR;
const int Column_ColumnType_ColumnType_ARRAYSIZE = Column_ColumnType_ColumnType_MAX + 1;

enum FlexImage_Format {
  FlexImage_Format_JPG = 0,
  FlexImage_Format_PNG = 1,
  FlexImage_Format_RAW_ARRAY = 2,
  FlexImage_Format_UNDEFINED = 3,
  FlexImage_Format_FlexImage_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FlexImage_Format_FlexImage_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FlexImage_Format_IsValid(int value);
const FlexImage_Format FlexImage_Format_Format_MIN = FlexImage_Format_JPG;
const FlexImage_Format FlexImage_Format_Format_MAX = FlexImage_Format_UNDEFINED;
const int FlexImage_Format_Format_ARRAYSIZE = FlexImage_Format_Format_MAX + 1;

// ===================================================================

class VegaSpec : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.VegaSpec) */ {
 public:
  VegaSpec();
  virtual ~VegaSpec();

  VegaSpec(const VegaSpec& from);

  inline VegaSpec& operator=(const VegaSpec& from) {
    CopyFrom(from);
    return *this;
  }

  static const VegaSpec& default_instance();

  static inline const VegaSpec* internal_default_instance() {
    return reinterpret_cast<const VegaSpec*>(
               &_VegaSpec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VegaSpec* other);

  // implements Message ----------------------------------------------

  inline VegaSpec* New() const PROTOBUF_FINAL { return New(NULL); }

  VegaSpec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VegaSpec& from);
  void MergeFrom(const VegaSpec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VegaSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string spec = 1;
  void clear_spec();
  static const int kSpecFieldNumber = 1;
  const ::std::string& spec() const;
  void set_spec(const ::std::string& value);
  #if LANG_CXX11
  void set_spec(::std::string&& value);
  #endif
  void set_spec(const char* value);
  void set_spec(const char* value, size_t size);
  ::std::string* mutable_spec();
  ::std::string* release_spec();
  void set_allocated_spec(::std::string* spec);

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.VegaSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr spec_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VegaData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.VegaData) */ {
 public:
  VegaData();
  virtual ~VegaData();

  VegaData(const VegaData& from);

  inline VegaData& operator=(const VegaData& from) {
    CopyFrom(from);
    return *this;
  }

  static const VegaData& default_instance();

  static inline const VegaData* internal_default_instance() {
    return reinterpret_cast<const VegaData*>(
               &_VegaData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(VegaData* other);

  // implements Message ----------------------------------------------

  inline VegaData* New() const PROTOBUF_FINAL { return New(NULL); }

  VegaData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VegaData& from);
  void MergeFrom(const VegaData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VegaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.VegaData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Column : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.Column) */ {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }

  static const Column& default_instance();

  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Column* other);

  // implements Message ----------------------------------------------

  inline Column* New() const PROTOBUF_FINAL { return New(NULL); }

  Column* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Column* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Column_ColumnType ColumnType;
  static const ColumnType INTEGER =
    Column_ColumnType_INTEGER;
  static const ColumnType FLOAT =
    Column_ColumnType_FLOAT;
  static const ColumnType STRING =
    Column_ColumnType_STRING;
  static const ColumnType VECTOR =
    Column_ColumnType_VECTOR;
  static const ColumnType LIST =
    Column_ColumnType_LIST;
  static const ColumnType DICT =
    Column_ColumnType_DICT;
  static const ColumnType DATETIME =
    Column_ColumnType_DATETIME;
  static const ColumnType UNDEFINED =
    Column_ColumnType_UNDEFINED;
  static const ColumnType IMAGE =
    Column_ColumnType_IMAGE;
  static const ColumnType ND_VECTOR =
    Column_ColumnType_ND_VECTOR;
  static inline bool ColumnType_IsValid(int value) {
    return Column_ColumnType_IsValid(value);
  }
  static const ColumnType ColumnType_MIN =
    Column_ColumnType_ColumnType_MIN;
  static const ColumnType ColumnType_MAX =
    Column_ColumnType_ColumnType_MAX;
  static const int ColumnType_ARRAYSIZE =
    Column_ColumnType_ColumnType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .turi.visualization.pipe.Column.ColumnType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::turi::visualization::pipe::Column_ColumnType type() const;
  void set_type(::turi::visualization::pipe::Column_ColumnType value);

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.Column)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableSpec : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.TableSpec) */ {
 public:
  TableSpec();
  virtual ~TableSpec();

  TableSpec(const TableSpec& from);

  inline TableSpec& operator=(const TableSpec& from) {
    CopyFrom(from);
    return *this;
  }

  static const TableSpec& default_instance();

  static inline const TableSpec* internal_default_instance() {
    return reinterpret_cast<const TableSpec*>(
               &_TableSpec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TableSpec* other);

  // implements Message ----------------------------------------------

  inline TableSpec* New() const PROTOBUF_FINAL { return New(NULL); }

  TableSpec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TableSpec& from);
  void MergeFrom(const TableSpec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TableSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .turi.visualization.pipe.Column columns = 3;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 3;
  const ::turi::visualization::pipe::Column& columns(int index) const;
  ::turi::visualization::pipe::Column* mutable_columns(int index);
  ::turi::visualization::pipe::Column* add_columns();
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::Column >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::Column >&
      columns() const;

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // int32 size = 1;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.TableSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::Column > columns_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::int32 size_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexVec : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexVec) */ {
 public:
  FlexVec();
  virtual ~FlexVec();

  FlexVec(const FlexVec& from);

  inline FlexVec& operator=(const FlexVec& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexVec& default_instance();

  static inline const FlexVec* internal_default_instance() {
    return reinterpret_cast<const FlexVec*>(
               &_FlexVec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(FlexVec* other);

  // implements Message ----------------------------------------------

  inline FlexVec* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexVec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexVec& from);
  void MergeFrom(const FlexVec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexVec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexVec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexList) */ {
 public:
  FlexList();
  virtual ~FlexList();

  FlexList(const FlexList& from);

  inline FlexList& operator=(const FlexList& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexList& default_instance();

  static inline const FlexList* internal_default_instance() {
    return reinterpret_cast<const FlexList*>(
               &_FlexList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(FlexList* other);

  // implements Message ----------------------------------------------

  inline FlexList* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexList& from);
  void MergeFrom(const FlexList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .turi.visualization.pipe.FlexibleType value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::turi::visualization::pipe::FlexibleType& value(int index) const;
  ::turi::visualization::pipe::FlexibleType* mutable_value(int index);
  ::turi::visualization::pipe::FlexibleType* add_value();
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >&
      value() const;

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType > value_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexDatetime : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexDatetime) */ {
 public:
  FlexDatetime();
  virtual ~FlexDatetime();

  FlexDatetime(const FlexDatetime& from);

  inline FlexDatetime& operator=(const FlexDatetime& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexDatetime& default_instance();

  static inline const FlexDatetime* internal_default_instance() {
    return reinterpret_cast<const FlexDatetime*>(
               &_FlexDatetime_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(FlexDatetime* other);

  // implements Message ----------------------------------------------

  inline FlexDatetime* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexDatetime* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexDatetime& from);
  void MergeFrom(const FlexDatetime& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexDatetime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 posix_timestamp = 1;
  void clear_posix_timestamp();
  static const int kPosixTimestampFieldNumber = 1;
  ::google::protobuf::uint64 posix_timestamp() const;
  void set_posix_timestamp(::google::protobuf::uint64 value);

  // int32 tz_15min_offset = 2;
  void clear_tz_15min_offset();
  static const int kTz15MinOffsetFieldNumber = 2;
  ::google::protobuf::int32 tz_15min_offset() const;
  void set_tz_15min_offset(::google::protobuf::int32 value);

  // int32 microsecond = 3;
  void clear_microsecond();
  static const int kMicrosecondFieldNumber = 3;
  ::google::protobuf::int32 microsecond() const;
  void set_microsecond(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexDatetime)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 posix_timestamp_;
  ::google::protobuf::int32 tz_15min_offset_;
  ::google::protobuf::int32 microsecond_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class FlexDict : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexDict) */ {
 public:
  FlexDict();
  virtual ~FlexDict();

  FlexDict(const FlexDict& from);

  inline FlexDict& operator=(const FlexDict& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexDict& default_instance();

  static inline const FlexDict* internal_default_instance() {
    return reinterpret_cast<const FlexDict*>(
               &_FlexDict_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(FlexDict* other);

  // implements Message ----------------------------------------------

  inline FlexDict* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexDict* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexDict& from);
  void MergeFrom(const FlexDict& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexDict* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .turi.visualization.pipe.FlexibleType> dict = 6;
  int dict_size() const;
  void clear_dict();
  static const int kDictFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::turi::visualization::pipe::FlexibleType >&
      dict() const;
  ::google::protobuf::Map< ::std::string, ::turi::visualization::pipe::FlexibleType >*
      mutable_dict();

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexDict)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::turi::visualization::pipe::FlexibleType,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      FlexDict_DictEntry;
  ::google::protobuf::internal::MapFieldLite<
      FlexDict_DictEntry,
      ::std::string, ::turi::visualization::pipe::FlexibleType,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > dict_;
  private:
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexUndefined : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexUndefined) */ {
 public:
  FlexUndefined();
  virtual ~FlexUndefined();

  FlexUndefined(const FlexUndefined& from);

  inline FlexUndefined& operator=(const FlexUndefined& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexUndefined& default_instance();

  static inline const FlexUndefined* internal_default_instance() {
    return reinterpret_cast<const FlexUndefined*>(
               &_FlexUndefined_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(FlexUndefined* other);

  // implements Message ----------------------------------------------

  inline FlexUndefined* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexUndefined* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexUndefined& from);
  void MergeFrom(const FlexUndefined& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexUndefined* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexUndefined)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexImage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexImage) */ {
 public:
  FlexImage();
  virtual ~FlexImage();

  FlexImage(const FlexImage& from);

  inline FlexImage& operator=(const FlexImage& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexImage& default_instance();

  static inline const FlexImage* internal_default_instance() {
    return reinterpret_cast<const FlexImage*>(
               &_FlexImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(FlexImage* other);

  // implements Message ----------------------------------------------

  inline FlexImage* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexImage& from);
  void MergeFrom(const FlexImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FlexImage_Format Format;
  static const Format JPG =
    FlexImage_Format_JPG;
  static const Format PNG =
    FlexImage_Format_PNG;
  static const Format RAW_ARRAY =
    FlexImage_Format_RAW_ARRAY;
  static const Format UNDEFINED =
    FlexImage_Format_UNDEFINED;
  static inline bool Format_IsValid(int value) {
    return FlexImage_Format_IsValid(value);
  }
  static const Format Format_MIN =
    FlexImage_Format_Format_MIN;
  static const Format Format_MAX =
    FlexImage_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    FlexImage_Format_Format_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // bytes image_data = 10;
  void clear_image_data();
  static const int kImageDataFieldNumber = 10;
  const ::std::string& image_data() const;
  void set_image_data(const ::std::string& value);
  #if LANG_CXX11
  void set_image_data(::std::string&& value);
  #endif
  void set_image_data(const char* value);
  void set_image_data(const void* value, size_t size);
  ::std::string* mutable_image_data();
  ::std::string* release_image_data();
  void set_allocated_image_data(::std::string* image_data);

  // int32 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 channels = 3;
  void clear_channels();
  static const int kChannelsFieldNumber = 3;
  ::google::protobuf::int32 channels() const;
  void set_channels(::google::protobuf::int32 value);

  // .turi.visualization.pipe.FlexImage.Format format = 4;
  void clear_format();
  static const int kFormatFieldNumber = 4;
  ::turi::visualization::pipe::FlexImage_Format format() const;
  void set_format(::turi::visualization::pipe::FlexImage_Format value);

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexImage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr image_data_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 channels_;
  int format_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexNDVectorDimension : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexNDVectorDimension) */ {
 public:
  FlexNDVectorDimension();
  virtual ~FlexNDVectorDimension();

  FlexNDVectorDimension(const FlexNDVectorDimension& from);

  inline FlexNDVectorDimension& operator=(const FlexNDVectorDimension& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexNDVectorDimension& default_instance();

  static inline const FlexNDVectorDimension* internal_default_instance() {
    return reinterpret_cast<const FlexNDVectorDimension*>(
               &_FlexNDVectorDimension_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(FlexNDVectorDimension* other);

  // implements Message ----------------------------------------------

  inline FlexNDVectorDimension* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexNDVectorDimension* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexNDVectorDimension& from);
  void MergeFrom(const FlexNDVectorDimension& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexNDVectorDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .turi.visualization.pipe.FlexNDVector dimension = 1;
  int dimension_size() const;
  void clear_dimension();
  static const int kDimensionFieldNumber = 1;
  const ::turi::visualization::pipe::FlexNDVector& dimension(int index) const;
  ::turi::visualization::pipe::FlexNDVector* mutable_dimension(int index);
  ::turi::visualization::pipe::FlexNDVector* add_dimension();
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexNDVector >*
      mutable_dimension();
  const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexNDVector >&
      dimension() const;

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexNDVectorDimension)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexNDVector > dimension_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexNDVector : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexNDVector) */ {
 public:
  FlexNDVector();
  virtual ~FlexNDVector();

  FlexNDVector(const FlexNDVector& from);

  inline FlexNDVector& operator=(const FlexNDVector& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexNDVector& default_instance();

  enum VectorCase {
    kDimension = 1,
    kValues = 2,
    VECTOR_NOT_SET = 0,
  };

  static inline const FlexNDVector* internal_default_instance() {
    return reinterpret_cast<const FlexNDVector*>(
               &_FlexNDVector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(FlexNDVector* other);

  // implements Message ----------------------------------------------

  inline FlexNDVector* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexNDVector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexNDVector& from);
  void MergeFrom(const FlexNDVector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexNDVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .turi.visualization.pipe.FlexNDVectorDimension dimension = 1;
  bool has_dimension() const;
  void clear_dimension();
  static const int kDimensionFieldNumber = 1;
  const ::turi::visualization::pipe::FlexNDVectorDimension& dimension() const;
  ::turi::visualization::pipe::FlexNDVectorDimension* mutable_dimension();
  ::turi::visualization::pipe::FlexNDVectorDimension* release_dimension();
  void set_allocated_dimension(::turi::visualization::pipe::FlexNDVectorDimension* dimension);

  // .turi.visualization.pipe.FlexVec values = 2;
  bool has_values() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::turi::visualization::pipe::FlexVec& values() const;
  ::turi::visualization::pipe::FlexVec* mutable_values();
  ::turi::visualization::pipe::FlexVec* release_values();
  void set_allocated_values(::turi::visualization::pipe::FlexVec* values);

  VectorCase vector_case() const;
  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexNDVector)
 private:
  void set_has_dimension();
  void set_has_values();

  inline bool has_vector() const;
  void clear_vector();
  inline void clear_has_vector();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union VectorUnion {
    VectorUnion() {}
    ::turi::visualization::pipe::FlexNDVectorDimension* dimension_;
    ::turi::visualization::pipe::FlexVec* values_;
  } vector_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlexibleType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.FlexibleType) */ {
 public:
  FlexibleType();
  virtual ~FlexibleType();

  FlexibleType(const FlexibleType& from);

  inline FlexibleType& operator=(const FlexibleType& from) {
    CopyFrom(from);
    return *this;
  }

  static const FlexibleType& default_instance();

  enum ValueCase {
    kInteger = 1,
    kFloat = 2,
    kString = 3,
    kVector = 4,
    kList = 5,
    kDict = 6,
    kDatetime = 7,
    kUndefined = 8,
    kImage = 9,
    kNdVector = 10,
    VALUE_NOT_SET = 0,
  };

  static inline const FlexibleType* internal_default_instance() {
    return reinterpret_cast<const FlexibleType*>(
               &_FlexibleType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(FlexibleType* other);

  // implements Message ----------------------------------------------

  inline FlexibleType* New() const PROTOBUF_FINAL { return New(NULL); }

  FlexibleType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const FlexibleType& from);
  void MergeFrom(const FlexibleType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlexibleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 integer = 1;
  private:
  bool has_integer() const;
  public:
  void clear_integer();
  static const int kIntegerFieldNumber = 1;
  ::google::protobuf::int64 integer() const;
  void set_integer(::google::protobuf::int64 value);

  // float float = 2;
  private:
  bool has_float_() const;
  public:
  void clear_float_();
  static const int kFloatFieldNumber = 2;
  float float_() const;
  void set_float_(float value);

  // string string = 3;
  private:
  bool has_string() const;
  public:
  void clear_string();
  static const int kStringFieldNumber = 3;
  const ::std::string& string() const;
  void set_string(const ::std::string& value);
  #if LANG_CXX11
  void set_string(::std::string&& value);
  #endif
  void set_string(const char* value);
  void set_string(const char* value, size_t size);
  ::std::string* mutable_string();
  ::std::string* release_string();
  void set_allocated_string(::std::string* string);

  // .turi.visualization.pipe.FlexVec vector = 4;
  bool has_vector() const;
  void clear_vector();
  static const int kVectorFieldNumber = 4;
  const ::turi::visualization::pipe::FlexVec& vector() const;
  ::turi::visualization::pipe::FlexVec* mutable_vector();
  ::turi::visualization::pipe::FlexVec* release_vector();
  void set_allocated_vector(::turi::visualization::pipe::FlexVec* vector);

  // .turi.visualization.pipe.FlexList list = 5;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 5;
  const ::turi::visualization::pipe::FlexList& list() const;
  ::turi::visualization::pipe::FlexList* mutable_list();
  ::turi::visualization::pipe::FlexList* release_list();
  void set_allocated_list(::turi::visualization::pipe::FlexList* list);

  // .turi.visualization.pipe.FlexDict dict = 6;
  bool has_dict() const;
  void clear_dict();
  static const int kDictFieldNumber = 6;
  const ::turi::visualization::pipe::FlexDict& dict() const;
  ::turi::visualization::pipe::FlexDict* mutable_dict();
  ::turi::visualization::pipe::FlexDict* release_dict();
  void set_allocated_dict(::turi::visualization::pipe::FlexDict* dict);

  // .turi.visualization.pipe.FlexDatetime datetime = 7;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDatetimeFieldNumber = 7;
  const ::turi::visualization::pipe::FlexDatetime& datetime() const;
  ::turi::visualization::pipe::FlexDatetime* mutable_datetime();
  ::turi::visualization::pipe::FlexDatetime* release_datetime();
  void set_allocated_datetime(::turi::visualization::pipe::FlexDatetime* datetime);

  // .turi.visualization.pipe.FlexUndefined undefined = 8;
  bool has_undefined() const;
  void clear_undefined();
  static const int kUndefinedFieldNumber = 8;
  const ::turi::visualization::pipe::FlexUndefined& undefined() const;
  ::turi::visualization::pipe::FlexUndefined* mutable_undefined();
  ::turi::visualization::pipe::FlexUndefined* release_undefined();
  void set_allocated_undefined(::turi::visualization::pipe::FlexUndefined* undefined);

  // .turi.visualization.pipe.FlexImage image = 9;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 9;
  const ::turi::visualization::pipe::FlexImage& image() const;
  ::turi::visualization::pipe::FlexImage* mutable_image();
  ::turi::visualization::pipe::FlexImage* release_image();
  void set_allocated_image(::turi::visualization::pipe::FlexImage* image);

  // .turi.visualization.pipe.FlexNDVector nd_vector = 10;
  bool has_nd_vector() const;
  void clear_nd_vector();
  static const int kNdVectorFieldNumber = 10;
  const ::turi::visualization::pipe::FlexNDVector& nd_vector() const;
  ::turi::visualization::pipe::FlexNDVector* mutable_nd_vector();
  ::turi::visualization::pipe::FlexNDVector* release_nd_vector();
  void set_allocated_nd_vector(::turi::visualization::pipe::FlexNDVector* nd_vector);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.FlexibleType)
 private:
  void set_has_integer();
  void set_has_float_();
  void set_has_string();
  void set_has_vector();
  void set_has_list();
  void set_has_dict();
  void set_has_datetime();
  void set_has_undefined();
  void set_has_image();
  void set_has_nd_vector();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::int64 integer_;
    float float__;
    ::google::protobuf::internal::ArenaStringPtr string_;
    ::turi::visualization::pipe::FlexVec* vector_;
    ::turi::visualization::pipe::FlexList* list_;
    ::turi::visualization::pipe::FlexDict* dict_;
    ::turi::visualization::pipe::FlexDatetime* datetime_;
    ::turi::visualization::pipe::FlexUndefined* undefined_;
    ::turi::visualization::pipe::FlexImage* image_;
    ::turi::visualization::pipe::FlexNDVector* nd_vector_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableRow : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.TableRow) */ {
 public:
  TableRow();
  virtual ~TableRow();

  TableRow(const TableRow& from);

  inline TableRow& operator=(const TableRow& from) {
    CopyFrom(from);
    return *this;
  }

  static const TableRow& default_instance();

  static inline const TableRow* internal_default_instance() {
    return reinterpret_cast<const TableRow*>(
               &_TableRow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TableRow* other);

  // implements Message ----------------------------------------------

  inline TableRow* New() const PROTOBUF_FINAL { return New(NULL); }

  TableRow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TableRow& from);
  void MergeFrom(const TableRow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TableRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .turi.visualization.pipe.FlexibleType data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::turi::visualization::pipe::FlexibleType& data(int index) const;
  ::turi::visualization::pipe::FlexibleType* mutable_data(int index);
  ::turi::visualization::pipe::FlexibleType* add_data();
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >&
      data() const;

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.TableRow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType > data_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:turi.visualization.pipe.TableData) */ {
 public:
  TableData();
  virtual ~TableData();

  TableData(const TableData& from);

  inline TableData& operator=(const TableData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TableData& default_instance();

  static inline const TableData* internal_default_instance() {
    return reinterpret_cast<const TableData*>(
               &_TableData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(TableData* other);

  // implements Message ----------------------------------------------

  inline TableData* New() const PROTOBUF_FINAL { return New(NULL); }

  TableData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TableData& from);
  void MergeFrom(const TableData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TableData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .turi.visualization.pipe.TableRow rows = 1;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 1;
  const ::turi::visualization::pipe::TableRow& rows(int index) const;
  ::turi::visualization::pipe::TableRow* mutable_rows(int index);
  ::turi::visualization::pipe::TableRow* add_rows();
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::TableRow >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::TableRow >&
      rows() const;

  // @@protoc_insertion_point(class_scope:turi.visualization.pipe.TableData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::TableRow > rows_;
  mutable int _cached_size_;
  friend struct protobuf_pipe_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// VegaSpec

// string spec = 1;
inline void VegaSpec::clear_spec() {
  spec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VegaSpec::spec() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.VegaSpec.spec)
  return spec_.GetNoArena();
}
inline void VegaSpec::set_spec(const ::std::string& value) {
  
  spec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.VegaSpec.spec)
}
#if LANG_CXX11
inline void VegaSpec::set_spec(::std::string&& value) {
  
  spec_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:turi.visualization.pipe.VegaSpec.spec)
}
#endif
inline void VegaSpec::set_spec(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  spec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:turi.visualization.pipe.VegaSpec.spec)
}
inline void VegaSpec::set_spec(const char* value, size_t size) {
  
  spec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:turi.visualization.pipe.VegaSpec.spec)
}
inline ::std::string* VegaSpec::mutable_spec() {
  
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.VegaSpec.spec)
  return spec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VegaSpec::release_spec() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.VegaSpec.spec)
  
  return spec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VegaSpec::set_allocated_spec(::std::string* spec) {
  if (spec != NULL) {
    
  } else {
    
  }
  spec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spec);
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.VegaSpec.spec)
}

// -------------------------------------------------------------------

// VegaData

// string data = 1;
inline void VegaData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VegaData::data() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.VegaData.data)
  return data_.GetNoArena();
}
inline void VegaData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.VegaData.data)
}
#if LANG_CXX11
inline void VegaData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:turi.visualization.pipe.VegaData.data)
}
#endif
inline void VegaData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:turi.visualization.pipe.VegaData.data)
}
inline void VegaData::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:turi.visualization.pipe.VegaData.data)
}
inline ::std::string* VegaData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.VegaData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VegaData::release_data() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.VegaData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VegaData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.VegaData.data)
}

// -------------------------------------------------------------------

// Column

// string name = 1;
inline void Column::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.Column.name)
  return name_.GetNoArena();
}
inline void Column::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.Column.name)
}
#if LANG_CXX11
inline void Column::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:turi.visualization.pipe.Column.name)
}
#endif
inline void Column::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:turi.visualization.pipe.Column.name)
}
inline void Column::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:turi.visualization.pipe.Column.name)
}
inline ::std::string* Column::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.Column.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.Column.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.Column.name)
}

// .turi.visualization.pipe.Column.ColumnType type = 2;
inline void Column::clear_type() {
  type_ = 0;
}
inline ::turi::visualization::pipe::Column_ColumnType Column::type() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.Column.type)
  return static_cast< ::turi::visualization::pipe::Column_ColumnType >(type_);
}
inline void Column::set_type(::turi::visualization::pipe::Column_ColumnType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.Column.type)
}

// -------------------------------------------------------------------

// TableSpec

// int32 size = 1;
inline void TableSpec::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 TableSpec::size() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.TableSpec.size)
  return size_;
}
inline void TableSpec::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.TableSpec.size)
}

// string title = 2;
inline void TableSpec::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableSpec::title() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.TableSpec.title)
  return title_.GetNoArena();
}
inline void TableSpec::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.TableSpec.title)
}
#if LANG_CXX11
inline void TableSpec::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:turi.visualization.pipe.TableSpec.title)
}
#endif
inline void TableSpec::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:turi.visualization.pipe.TableSpec.title)
}
inline void TableSpec::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:turi.visualization.pipe.TableSpec.title)
}
inline ::std::string* TableSpec::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.TableSpec.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableSpec::release_title() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.TableSpec.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableSpec::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.TableSpec.title)
}

// repeated .turi.visualization.pipe.Column columns = 3;
inline int TableSpec::columns_size() const {
  return columns_.size();
}
inline void TableSpec::clear_columns() {
  columns_.Clear();
}
inline const ::turi::visualization::pipe::Column& TableSpec::columns(int index) const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.TableSpec.columns)
  return columns_.Get(index);
}
inline ::turi::visualization::pipe::Column* TableSpec::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.TableSpec.columns)
  return columns_.Mutable(index);
}
inline ::turi::visualization::pipe::Column* TableSpec::add_columns() {
  // @@protoc_insertion_point(field_add:turi.visualization.pipe.TableSpec.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::Column >*
TableSpec::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:turi.visualization.pipe.TableSpec.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::Column >&
TableSpec::columns() const {
  // @@protoc_insertion_point(field_list:turi.visualization.pipe.TableSpec.columns)
  return columns_;
}

// -------------------------------------------------------------------

// FlexVec

// repeated float value = 1;
inline int FlexVec::value_size() const {
  return value_.size();
}
inline void FlexVec::clear_value() {
  value_.Clear();
}
inline float FlexVec::value(int index) const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexVec.value)
  return value_.Get(index);
}
inline void FlexVec::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexVec.value)
}
inline void FlexVec::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:turi.visualization.pipe.FlexVec.value)
}
inline const ::google::protobuf::RepeatedField< float >&
FlexVec::value() const {
  // @@protoc_insertion_point(field_list:turi.visualization.pipe.FlexVec.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
FlexVec::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:turi.visualization.pipe.FlexVec.value)
  return &value_;
}

// -------------------------------------------------------------------

// FlexList

// repeated .turi.visualization.pipe.FlexibleType value = 1;
inline int FlexList::value_size() const {
  return value_.size();
}
inline void FlexList::clear_value() {
  value_.Clear();
}
inline const ::turi::visualization::pipe::FlexibleType& FlexList::value(int index) const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexList.value)
  return value_.Get(index);
}
inline ::turi::visualization::pipe::FlexibleType* FlexList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexList.value)
  return value_.Mutable(index);
}
inline ::turi::visualization::pipe::FlexibleType* FlexList::add_value() {
  // @@protoc_insertion_point(field_add:turi.visualization.pipe.FlexList.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >*
FlexList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:turi.visualization.pipe.FlexList.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >&
FlexList::value() const {
  // @@protoc_insertion_point(field_list:turi.visualization.pipe.FlexList.value)
  return value_;
}

// -------------------------------------------------------------------

// FlexDatetime

// uint64 posix_timestamp = 1;
inline void FlexDatetime::clear_posix_timestamp() {
  posix_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FlexDatetime::posix_timestamp() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexDatetime.posix_timestamp)
  return posix_timestamp_;
}
inline void FlexDatetime::set_posix_timestamp(::google::protobuf::uint64 value) {
  
  posix_timestamp_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexDatetime.posix_timestamp)
}

// int32 tz_15min_offset = 2;
inline void FlexDatetime::clear_tz_15min_offset() {
  tz_15min_offset_ = 0;
}
inline ::google::protobuf::int32 FlexDatetime::tz_15min_offset() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexDatetime.tz_15min_offset)
  return tz_15min_offset_;
}
inline void FlexDatetime::set_tz_15min_offset(::google::protobuf::int32 value) {
  
  tz_15min_offset_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexDatetime.tz_15min_offset)
}

// int32 microsecond = 3;
inline void FlexDatetime::clear_microsecond() {
  microsecond_ = 0;
}
inline ::google::protobuf::int32 FlexDatetime::microsecond() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexDatetime.microsecond)
  return microsecond_;
}
inline void FlexDatetime::set_microsecond(::google::protobuf::int32 value) {
  
  microsecond_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexDatetime.microsecond)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FlexDict

// map<string, .turi.visualization.pipe.FlexibleType> dict = 6;
inline int FlexDict::dict_size() const {
  return dict_.size();
}
inline void FlexDict::clear_dict() {
  dict_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::turi::visualization::pipe::FlexibleType >&
FlexDict::dict() const {
  // @@protoc_insertion_point(field_map:turi.visualization.pipe.FlexDict.dict)
  return dict_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::turi::visualization::pipe::FlexibleType >*
FlexDict::mutable_dict() {
  // @@protoc_insertion_point(field_mutable_map:turi.visualization.pipe.FlexDict.dict)
  return dict_.MutableMap();
}

// -------------------------------------------------------------------

// FlexUndefined

// -------------------------------------------------------------------

// FlexImage

// int32 height = 1;
inline void FlexImage::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 FlexImage::height() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexImage.height)
  return height_;
}
inline void FlexImage::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexImage.height)
}

// int32 width = 2;
inline void FlexImage::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 FlexImage::width() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexImage.width)
  return width_;
}
inline void FlexImage::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexImage.width)
}

// int32 channels = 3;
inline void FlexImage::clear_channels() {
  channels_ = 0;
}
inline ::google::protobuf::int32 FlexImage::channels() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexImage.channels)
  return channels_;
}
inline void FlexImage::set_channels(::google::protobuf::int32 value) {
  
  channels_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexImage.channels)
}

// .turi.visualization.pipe.FlexImage.Format format = 4;
inline void FlexImage::clear_format() {
  format_ = 0;
}
inline ::turi::visualization::pipe::FlexImage_Format FlexImage::format() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexImage.format)
  return static_cast< ::turi::visualization::pipe::FlexImage_Format >(format_);
}
inline void FlexImage::set_format(::turi::visualization::pipe::FlexImage_Format value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexImage.format)
}

// bytes image_data = 10;
inline void FlexImage::clear_image_data() {
  image_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FlexImage::image_data() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexImage.image_data)
  return image_data_.GetNoArena();
}
inline void FlexImage::set_image_data(const ::std::string& value) {
  
  image_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexImage.image_data)
}
#if LANG_CXX11
inline void FlexImage::set_image_data(::std::string&& value) {
  
  image_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:turi.visualization.pipe.FlexImage.image_data)
}
#endif
inline void FlexImage::set_image_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:turi.visualization.pipe.FlexImage.image_data)
}
inline void FlexImage::set_image_data(const void* value, size_t size) {
  
  image_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:turi.visualization.pipe.FlexImage.image_data)
}
inline ::std::string* FlexImage::mutable_image_data() {
  
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexImage.image_data)
  return image_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlexImage::release_image_data() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexImage.image_data)
  
  return image_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlexImage::set_allocated_image_data(::std::string* image_data) {
  if (image_data != NULL) {
    
  } else {
    
  }
  image_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_data);
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexImage.image_data)
}

// -------------------------------------------------------------------

// FlexNDVectorDimension

// repeated .turi.visualization.pipe.FlexNDVector dimension = 1;
inline int FlexNDVectorDimension::dimension_size() const {
  return dimension_.size();
}
inline void FlexNDVectorDimension::clear_dimension() {
  dimension_.Clear();
}
inline const ::turi::visualization::pipe::FlexNDVector& FlexNDVectorDimension::dimension(int index) const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexNDVectorDimension.dimension)
  return dimension_.Get(index);
}
inline ::turi::visualization::pipe::FlexNDVector* FlexNDVectorDimension::mutable_dimension(int index) {
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexNDVectorDimension.dimension)
  return dimension_.Mutable(index);
}
inline ::turi::visualization::pipe::FlexNDVector* FlexNDVectorDimension::add_dimension() {
  // @@protoc_insertion_point(field_add:turi.visualization.pipe.FlexNDVectorDimension.dimension)
  return dimension_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexNDVector >*
FlexNDVectorDimension::mutable_dimension() {
  // @@protoc_insertion_point(field_mutable_list:turi.visualization.pipe.FlexNDVectorDimension.dimension)
  return &dimension_;
}
inline const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexNDVector >&
FlexNDVectorDimension::dimension() const {
  // @@protoc_insertion_point(field_list:turi.visualization.pipe.FlexNDVectorDimension.dimension)
  return dimension_;
}

// -------------------------------------------------------------------

// FlexNDVector

// .turi.visualization.pipe.FlexNDVectorDimension dimension = 1;
inline bool FlexNDVector::has_dimension() const {
  return vector_case() == kDimension;
}
inline void FlexNDVector::set_has_dimension() {
  _oneof_case_[0] = kDimension;
}
inline void FlexNDVector::clear_dimension() {
  if (has_dimension()) {
    delete vector_.dimension_;
    clear_has_vector();
  }
}
inline  const ::turi::visualization::pipe::FlexNDVectorDimension& FlexNDVector::dimension() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexNDVector.dimension)
  return has_dimension()
      ? *vector_.dimension_
      : ::turi::visualization::pipe::FlexNDVectorDimension::default_instance();
}
inline ::turi::visualization::pipe::FlexNDVectorDimension* FlexNDVector::mutable_dimension() {
  if (!has_dimension()) {
    clear_vector();
    set_has_dimension();
    vector_.dimension_ = new ::turi::visualization::pipe::FlexNDVectorDimension;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexNDVector.dimension)
  return vector_.dimension_;
}
inline ::turi::visualization::pipe::FlexNDVectorDimension* FlexNDVector::release_dimension() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexNDVector.dimension)
  if (has_dimension()) {
    clear_has_vector();
    ::turi::visualization::pipe::FlexNDVectorDimension* temp = vector_.dimension_;
    vector_.dimension_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexNDVector::set_allocated_dimension(::turi::visualization::pipe::FlexNDVectorDimension* dimension) {
  clear_vector();
  if (dimension) {
    set_has_dimension();
    vector_.dimension_ = dimension;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexNDVector.dimension)
}

// .turi.visualization.pipe.FlexVec values = 2;
inline bool FlexNDVector::has_values() const {
  return vector_case() == kValues;
}
inline void FlexNDVector::set_has_values() {
  _oneof_case_[0] = kValues;
}
inline void FlexNDVector::clear_values() {
  if (has_values()) {
    delete vector_.values_;
    clear_has_vector();
  }
}
inline  const ::turi::visualization::pipe::FlexVec& FlexNDVector::values() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexNDVector.values)
  return has_values()
      ? *vector_.values_
      : ::turi::visualization::pipe::FlexVec::default_instance();
}
inline ::turi::visualization::pipe::FlexVec* FlexNDVector::mutable_values() {
  if (!has_values()) {
    clear_vector();
    set_has_values();
    vector_.values_ = new ::turi::visualization::pipe::FlexVec;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexNDVector.values)
  return vector_.values_;
}
inline ::turi::visualization::pipe::FlexVec* FlexNDVector::release_values() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexNDVector.values)
  if (has_values()) {
    clear_has_vector();
    ::turi::visualization::pipe::FlexVec* temp = vector_.values_;
    vector_.values_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexNDVector::set_allocated_values(::turi::visualization::pipe::FlexVec* values) {
  clear_vector();
  if (values) {
    set_has_values();
    vector_.values_ = values;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexNDVector.values)
}

inline bool FlexNDVector::has_vector() const {
  return vector_case() != VECTOR_NOT_SET;
}
inline void FlexNDVector::clear_has_vector() {
  _oneof_case_[0] = VECTOR_NOT_SET;
}
inline FlexNDVector::VectorCase FlexNDVector::vector_case() const {
  return FlexNDVector::VectorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FlexibleType

// int64 integer = 1;
inline bool FlexibleType::has_integer() const {
  return value_case() == kInteger;
}
inline void FlexibleType::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void FlexibleType::clear_integer() {
  if (has_integer()) {
    value_.integer_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 FlexibleType::integer() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.integer)
  if (has_integer()) {
    return value_.integer_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void FlexibleType::set_integer(::google::protobuf::int64 value) {
  if (!has_integer()) {
    clear_value();
    set_has_integer();
  }
  value_.integer_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexibleType.integer)
}

// float float = 2;
inline bool FlexibleType::has_float_() const {
  return value_case() == kFloat;
}
inline void FlexibleType::set_has_float_() {
  _oneof_case_[0] = kFloat;
}
inline void FlexibleType::clear_float_() {
  if (has_float_()) {
    value_.float__ = 0;
    clear_has_value();
  }
}
inline float FlexibleType::float_() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.float)
  if (has_float_()) {
    return value_.float__;
  }
  return 0;
}
inline void FlexibleType::set_float_(float value) {
  if (!has_float_()) {
    clear_value();
    set_has_float_();
  }
  value_.float__ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexibleType.float)
}

// string string = 3;
inline bool FlexibleType::has_string() const {
  return value_case() == kString;
}
inline void FlexibleType::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void FlexibleType::clear_string() {
  if (has_string()) {
    value_.string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& FlexibleType::string() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.string)
  if (has_string()) {
    return value_.string_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void FlexibleType::set_string(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexibleType.string)
  if (!has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexibleType.string)
}
#if LANG_CXX11
inline void FlexibleType::set_string(::std::string&& value) {
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.FlexibleType.string)
  if (!has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:turi.visualization.pipe.FlexibleType.string)
}
#endif
inline void FlexibleType::set_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:turi.visualization.pipe.FlexibleType.string)
}
inline void FlexibleType::set_string(const char* value, size_t size) {
  if (!has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:turi.visualization.pipe.FlexibleType.string)
}
inline ::std::string* FlexibleType::mutable_string() {
  if (!has_string()) {
    clear_value();
    set_has_string();
    value_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.string)
  return value_.string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlexibleType::release_string() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.string)
  if (has_string()) {
    clear_has_value();
    return value_.string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_string(::std::string* string) {
  if (!has_string()) {
    value_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (string != NULL) {
    set_has_string();
    value_.string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string);
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.string)
}

// .turi.visualization.pipe.FlexVec vector = 4;
inline bool FlexibleType::has_vector() const {
  return value_case() == kVector;
}
inline void FlexibleType::set_has_vector() {
  _oneof_case_[0] = kVector;
}
inline void FlexibleType::clear_vector() {
  if (has_vector()) {
    delete value_.vector_;
    clear_has_value();
  }
}
inline  const ::turi::visualization::pipe::FlexVec& FlexibleType::vector() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.vector)
  return has_vector()
      ? *value_.vector_
      : ::turi::visualization::pipe::FlexVec::default_instance();
}
inline ::turi::visualization::pipe::FlexVec* FlexibleType::mutable_vector() {
  if (!has_vector()) {
    clear_value();
    set_has_vector();
    value_.vector_ = new ::turi::visualization::pipe::FlexVec;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.vector)
  return value_.vector_;
}
inline ::turi::visualization::pipe::FlexVec* FlexibleType::release_vector() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.vector)
  if (has_vector()) {
    clear_has_value();
    ::turi::visualization::pipe::FlexVec* temp = value_.vector_;
    value_.vector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_vector(::turi::visualization::pipe::FlexVec* vector) {
  clear_value();
  if (vector) {
    set_has_vector();
    value_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.vector)
}

// .turi.visualization.pipe.FlexList list = 5;
inline bool FlexibleType::has_list() const {
  return value_case() == kList;
}
inline void FlexibleType::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void FlexibleType::clear_list() {
  if (has_list()) {
    delete value_.list_;
    clear_has_value();
  }
}
inline  const ::turi::visualization::pipe::FlexList& FlexibleType::list() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.list)
  return has_list()
      ? *value_.list_
      : ::turi::visualization::pipe::FlexList::default_instance();
}
inline ::turi::visualization::pipe::FlexList* FlexibleType::mutable_list() {
  if (!has_list()) {
    clear_value();
    set_has_list();
    value_.list_ = new ::turi::visualization::pipe::FlexList;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.list)
  return value_.list_;
}
inline ::turi::visualization::pipe::FlexList* FlexibleType::release_list() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.list)
  if (has_list()) {
    clear_has_value();
    ::turi::visualization::pipe::FlexList* temp = value_.list_;
    value_.list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_list(::turi::visualization::pipe::FlexList* list) {
  clear_value();
  if (list) {
    set_has_list();
    value_.list_ = list;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.list)
}

// .turi.visualization.pipe.FlexDict dict = 6;
inline bool FlexibleType::has_dict() const {
  return value_case() == kDict;
}
inline void FlexibleType::set_has_dict() {
  _oneof_case_[0] = kDict;
}
inline void FlexibleType::clear_dict() {
  if (has_dict()) {
    delete value_.dict_;
    clear_has_value();
  }
}
inline  const ::turi::visualization::pipe::FlexDict& FlexibleType::dict() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.dict)
  return has_dict()
      ? *value_.dict_
      : ::turi::visualization::pipe::FlexDict::default_instance();
}
inline ::turi::visualization::pipe::FlexDict* FlexibleType::mutable_dict() {
  if (!has_dict()) {
    clear_value();
    set_has_dict();
    value_.dict_ = new ::turi::visualization::pipe::FlexDict;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.dict)
  return value_.dict_;
}
inline ::turi::visualization::pipe::FlexDict* FlexibleType::release_dict() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.dict)
  if (has_dict()) {
    clear_has_value();
    ::turi::visualization::pipe::FlexDict* temp = value_.dict_;
    value_.dict_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_dict(::turi::visualization::pipe::FlexDict* dict) {
  clear_value();
  if (dict) {
    set_has_dict();
    value_.dict_ = dict;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.dict)
}

// .turi.visualization.pipe.FlexDatetime datetime = 7;
inline bool FlexibleType::has_datetime() const {
  return value_case() == kDatetime;
}
inline void FlexibleType::set_has_datetime() {
  _oneof_case_[0] = kDatetime;
}
inline void FlexibleType::clear_datetime() {
  if (has_datetime()) {
    delete value_.datetime_;
    clear_has_value();
  }
}
inline  const ::turi::visualization::pipe::FlexDatetime& FlexibleType::datetime() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.datetime)
  return has_datetime()
      ? *value_.datetime_
      : ::turi::visualization::pipe::FlexDatetime::default_instance();
}
inline ::turi::visualization::pipe::FlexDatetime* FlexibleType::mutable_datetime() {
  if (!has_datetime()) {
    clear_value();
    set_has_datetime();
    value_.datetime_ = new ::turi::visualization::pipe::FlexDatetime;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.datetime)
  return value_.datetime_;
}
inline ::turi::visualization::pipe::FlexDatetime* FlexibleType::release_datetime() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.datetime)
  if (has_datetime()) {
    clear_has_value();
    ::turi::visualization::pipe::FlexDatetime* temp = value_.datetime_;
    value_.datetime_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_datetime(::turi::visualization::pipe::FlexDatetime* datetime) {
  clear_value();
  if (datetime) {
    set_has_datetime();
    value_.datetime_ = datetime;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.datetime)
}

// .turi.visualization.pipe.FlexUndefined undefined = 8;
inline bool FlexibleType::has_undefined() const {
  return value_case() == kUndefined;
}
inline void FlexibleType::set_has_undefined() {
  _oneof_case_[0] = kUndefined;
}
inline void FlexibleType::clear_undefined() {
  if (has_undefined()) {
    delete value_.undefined_;
    clear_has_value();
  }
}
inline  const ::turi::visualization::pipe::FlexUndefined& FlexibleType::undefined() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.undefined)
  return has_undefined()
      ? *value_.undefined_
      : ::turi::visualization::pipe::FlexUndefined::default_instance();
}
inline ::turi::visualization::pipe::FlexUndefined* FlexibleType::mutable_undefined() {
  if (!has_undefined()) {
    clear_value();
    set_has_undefined();
    value_.undefined_ = new ::turi::visualization::pipe::FlexUndefined;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.undefined)
  return value_.undefined_;
}
inline ::turi::visualization::pipe::FlexUndefined* FlexibleType::release_undefined() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.undefined)
  if (has_undefined()) {
    clear_has_value();
    ::turi::visualization::pipe::FlexUndefined* temp = value_.undefined_;
    value_.undefined_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_undefined(::turi::visualization::pipe::FlexUndefined* undefined) {
  clear_value();
  if (undefined) {
    set_has_undefined();
    value_.undefined_ = undefined;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.undefined)
}

// .turi.visualization.pipe.FlexImage image = 9;
inline bool FlexibleType::has_image() const {
  return value_case() == kImage;
}
inline void FlexibleType::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void FlexibleType::clear_image() {
  if (has_image()) {
    delete value_.image_;
    clear_has_value();
  }
}
inline  const ::turi::visualization::pipe::FlexImage& FlexibleType::image() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.image)
  return has_image()
      ? *value_.image_
      : ::turi::visualization::pipe::FlexImage::default_instance();
}
inline ::turi::visualization::pipe::FlexImage* FlexibleType::mutable_image() {
  if (!has_image()) {
    clear_value();
    set_has_image();
    value_.image_ = new ::turi::visualization::pipe::FlexImage;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.image)
  return value_.image_;
}
inline ::turi::visualization::pipe::FlexImage* FlexibleType::release_image() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.image)
  if (has_image()) {
    clear_has_value();
    ::turi::visualization::pipe::FlexImage* temp = value_.image_;
    value_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_image(::turi::visualization::pipe::FlexImage* image) {
  clear_value();
  if (image) {
    set_has_image();
    value_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.image)
}

// .turi.visualization.pipe.FlexNDVector nd_vector = 10;
inline bool FlexibleType::has_nd_vector() const {
  return value_case() == kNdVector;
}
inline void FlexibleType::set_has_nd_vector() {
  _oneof_case_[0] = kNdVector;
}
inline void FlexibleType::clear_nd_vector() {
  if (has_nd_vector()) {
    delete value_.nd_vector_;
    clear_has_value();
  }
}
inline  const ::turi::visualization::pipe::FlexNDVector& FlexibleType::nd_vector() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.FlexibleType.nd_vector)
  return has_nd_vector()
      ? *value_.nd_vector_
      : ::turi::visualization::pipe::FlexNDVector::default_instance();
}
inline ::turi::visualization::pipe::FlexNDVector* FlexibleType::mutable_nd_vector() {
  if (!has_nd_vector()) {
    clear_value();
    set_has_nd_vector();
    value_.nd_vector_ = new ::turi::visualization::pipe::FlexNDVector;
  }
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.FlexibleType.nd_vector)
  return value_.nd_vector_;
}
inline ::turi::visualization::pipe::FlexNDVector* FlexibleType::release_nd_vector() {
  // @@protoc_insertion_point(field_release:turi.visualization.pipe.FlexibleType.nd_vector)
  if (has_nd_vector()) {
    clear_has_value();
    ::turi::visualization::pipe::FlexNDVector* temp = value_.nd_vector_;
    value_.nd_vector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void FlexibleType::set_allocated_nd_vector(::turi::visualization::pipe::FlexNDVector* nd_vector) {
  clear_value();
  if (nd_vector) {
    set_has_nd_vector();
    value_.nd_vector_ = nd_vector;
  }
  // @@protoc_insertion_point(field_set_allocated:turi.visualization.pipe.FlexibleType.nd_vector)
}

inline bool FlexibleType::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void FlexibleType::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline FlexibleType::ValueCase FlexibleType::value_case() const {
  return FlexibleType::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TableRow

// int32 id = 1;
inline void TableRow::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 TableRow::id() const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.TableRow.id)
  return id_;
}
inline void TableRow::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:turi.visualization.pipe.TableRow.id)
}

// repeated .turi.visualization.pipe.FlexibleType data = 2;
inline int TableRow::data_size() const {
  return data_.size();
}
inline void TableRow::clear_data() {
  data_.Clear();
}
inline const ::turi::visualization::pipe::FlexibleType& TableRow::data(int index) const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.TableRow.data)
  return data_.Get(index);
}
inline ::turi::visualization::pipe::FlexibleType* TableRow::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.TableRow.data)
  return data_.Mutable(index);
}
inline ::turi::visualization::pipe::FlexibleType* TableRow::add_data() {
  // @@protoc_insertion_point(field_add:turi.visualization.pipe.TableRow.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >*
TableRow::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:turi.visualization.pipe.TableRow.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::FlexibleType >&
TableRow::data() const {
  // @@protoc_insertion_point(field_list:turi.visualization.pipe.TableRow.data)
  return data_;
}

// -------------------------------------------------------------------

// TableData

// repeated .turi.visualization.pipe.TableRow rows = 1;
inline int TableData::rows_size() const {
  return rows_.size();
}
inline void TableData::clear_rows() {
  rows_.Clear();
}
inline const ::turi::visualization::pipe::TableRow& TableData::rows(int index) const {
  // @@protoc_insertion_point(field_get:turi.visualization.pipe.TableData.rows)
  return rows_.Get(index);
}
inline ::turi::visualization::pipe::TableRow* TableData::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:turi.visualization.pipe.TableData.rows)
  return rows_.Mutable(index);
}
inline ::turi::visualization::pipe::TableRow* TableData::add_rows() {
  // @@protoc_insertion_point(field_add:turi.visualization.pipe.TableData.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::TableRow >*
TableData::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:turi.visualization.pipe.TableData.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::turi::visualization::pipe::TableRow >&
TableData::rows() const {
  // @@protoc_insertion_point(field_list:turi.visualization.pipe.TableData.rows)
  return rows_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace pipe
}  // namespace visualization
}  // namespace turi

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::turi::visualization::pipe::Column_ColumnType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::turi::visualization::pipe::FlexImage_Format> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pipe_2eproto__INCLUDED
